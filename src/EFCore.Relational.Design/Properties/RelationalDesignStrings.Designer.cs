// <auto-generated />

using System.Reflection;
using System.Resources;
using JetBrains.Annotations;

namespace Microsoft.EntityFrameworkCore.Internal
{
    /// <summary>
    ///		This API supports the Entity Framework Core infrastructure and is not intended to be used
    ///     directly from your code. This API may change or be removed in future releases.
    /// </summary>
    public static class RelationalDesignStrings
    {
        private static readonly ResourceManager _resourceManager
            = new ResourceManager("Microsoft.EntityFrameworkCore.Properties.RelationalDesignStrings", typeof(RelationalDesignStrings).GetTypeInfo().Assembly);

        /// <summary>
        ///     Metadata model returned should not be null. Provider: {providerTypeName}.
        /// </summary>
        public static string ProviderReturnedNullModel([CanBeNull] object providerTypeName)
            => string.Format(
                GetString("ProviderReturnedNullModel", nameof(providerTypeName)),
                providerTypeName);

        /// <summary>
        ///     No files generated in directory {outputDirectoryName}. The following file(s) already exist and must be made writeable to continue: {readOnlyFiles}.
        /// </summary>
        public static string ReadOnlyFiles([CanBeNull] object outputDirectoryName, [CanBeNull] object readOnlyFiles)
            => string.Format(
                GetString("ReadOnlyFiles", nameof(outputDirectoryName), nameof(readOnlyFiles)),
                outputDirectoryName, readOnlyFiles);

        /// <summary>
        ///     Cannot scaffold the connection string. The "UseProviderMethodName" is missing from the scaffolding model.
        /// </summary>
        public static string MissingUseProviderMethodNameAnnotation
            => GetString("MissingUseProviderMethodNameAnnotation");

        /// <summary>
        ///     The following file(s) already exist in directory {outputDirectoryName}: {existingFiles}. Use the Force flag to overwrite these files.
        /// </summary>
        public static string ExistingFiles([CanBeNull] object outputDirectoryName, [CanBeNull] object existingFiles)
            => string.Format(
                GetString("ExistingFiles", nameof(outputDirectoryName), nameof(existingFiles)),
                outputDirectoryName, existingFiles);

        /// <summary>
        ///     Found a column on index {indexName} on table {tableName} with an empty or null name. Not including column in index.
        /// </summary>
        public static string ColumnNameEmptyOnIndex([CanBeNull] object indexName, [CanBeNull] object tableName)
            => string.Format(
                GetString("ColumnNameEmptyOnIndex", nameof(indexName), nameof(tableName)),
                indexName, tableName);

        /// <summary>
        ///     For foreign key with identity {id} on table {tableName}, unable to find the column called {principalColumnName} on the foreign key's principal table, {principaltableName}. Skipping foreign key.
        /// </summary>
        public static string PrincipalColumnNotFound([CanBeNull] object id, [CanBeNull] object tableName, [CanBeNull] object principalColumnName, [CanBeNull] object principaltableName)
            => string.Format(
                GetString("PrincipalColumnNotFound", nameof(id), nameof(tableName), nameof(principalColumnName), nameof(principaltableName)),
                id, tableName, principalColumnName, principaltableName);

        /// <summary>
        ///     Could not find type mapping for column '{columnName}' with data type '{dateType}'. Skipping column.
        /// </summary>
        public static string CannotFindTypeMappingForColumn([CanBeNull] object columnName, [CanBeNull] object dateType)
            => string.Format(
                GetString("CannotFindTypeMappingForColumn", nameof(columnName), nameof(dateType)),
                columnName, dateType);

        /// <summary>
        ///     Could not scaffold the foreign key '{foreignKeyName}'. A key for '{columnsList}' was not found in the principal entity type '{principalEntityType}'.
        /// </summary>
        public static string ForeignKeyScaffoldErrorPrincipalKeyNotFound([CanBeNull] object foreignKeyName, [CanBeNull] object columnsList, [CanBeNull] object principalEntityType)
            => string.Format(
                GetString("ForeignKeyScaffoldErrorPrincipalKeyNotFound", nameof(foreignKeyName), nameof(columnsList), nameof(principalEntityType)),
                foreignKeyName, columnsList, principalEntityType);

        /// <summary>
        ///     Could not scaffold the foreign key '{foreignKeyName}'. The referenced table could not be found. This most likely occurred because the referenced table was excluded from scaffolding.
        /// </summary>
        public static string ForeignKeyScaffoldErrorPrincipalTableNotFound([CanBeNull] object foreignKeyName)
            => string.Format(
                GetString("ForeignKeyScaffoldErrorPrincipalTableNotFound", nameof(foreignKeyName)),
                foreignKeyName);

        /// <summary>
        ///     Could not scaffold the foreign key '{foreignKeyName}'. The referenced table '{principaltableName}' could not be scaffolded.
        /// </summary>
        public static string ForeignKeyScaffoldErrorPrincipalTableScaffoldingError([CanBeNull] object foreignKeyName, [CanBeNull] object principaltableName)
            => string.Format(
                GetString("ForeignKeyScaffoldErrorPrincipalTableScaffoldingError", nameof(foreignKeyName), nameof(principaltableName)),
                foreignKeyName, principaltableName);

        /// <summary>
        ///     Could not scaffold the foreign key '{foreignKeyName}'.  The following columns in the foreign key could not be scaffolded: {columnNames}.
        /// </summary>
        public static string ForeignKeyScaffoldErrorPropertyNotFound([CanBeNull] object foreignKeyName, [CanBeNull] object columnNames)
            => string.Format(
                GetString("ForeignKeyScaffoldErrorPropertyNotFound", nameof(foreignKeyName), nameof(columnNames)),
                foreignKeyName, columnNames);

        /// <summary>
        ///     Could not scaffold the primary key for '{tableName}'. The following columns in the primary key could not be scaffolded: {columnNames}.
        /// </summary>
        public static string PrimaryKeyErrorPropertyNotFound([CanBeNull] object tableName, [CanBeNull] object columnNames)
            => string.Format(
                GetString("PrimaryKeyErrorPropertyNotFound", nameof(tableName), nameof(columnNames)),
                tableName, columnNames);

        /// <summary>
        ///     Unable to identify the primary key for table '{tableName}'.
        /// </summary>
        public static string MissingPrimaryKey([CanBeNull] object tableName)
            => string.Format(
                GetString("MissingPrimaryKey", nameof(tableName)),
                tableName);

        /// <summary>
        ///     Found table with name: {name}.
        /// </summary>
        public static string FoundTable([CanBeNull] object name)
            => string.Format(
                GetString("FoundTable", nameof(name)),
                name);

        /// <summary>
        ///     Table {tableName} is not included in the selection set. Skipping.
        /// </summary>
        public static string TableNotInSelectionSet([CanBeNull] object tableName)
            => string.Format(
                GetString("TableNotInSelectionSet", nameof(tableName)),
                tableName);

        /// <summary>
        ///     Column {columnName} belongs to table {tableName} which is not included in the selection set. Skipping.
        /// </summary>
        public static string ColumnNotInSelectionSet([CanBeNull] object columnName, [CanBeNull] object tableName)
            => string.Format(
                GetString("ColumnNotInSelectionSet", nameof(columnName), nameof(tableName)),
                columnName, tableName);

        /// <summary>
        ///     Found index with name: {indexName}, table: {tableName}, is unique: {isUnique}.
        /// </summary>
        public static string FoundIndex([CanBeNull] object indexName, [CanBeNull] object tableName, [CanBeNull] object isUnique)
            => string.Format(
                GetString("FoundIndex", nameof(indexName), nameof(tableName), nameof(isUnique)),
                indexName, tableName, isUnique);

        /// <summary>
        ///     Found index column on index {indexName} on table {tableName}, column name: {columnName}, ordinal: {ordinal}.
        /// </summary>
        public static string FoundIndexColumn([CanBeNull] object indexName, [CanBeNull] object tableName, [CanBeNull] object columnName, [CanBeNull] object ordinal)
            => string.Format(
                GetString("FoundIndexColumn", nameof(indexName), nameof(tableName), nameof(columnName), nameof(ordinal)),
                indexName, tableName, columnName, ordinal);

        /// <summary>
        ///     Index column {columnName} belongs to index {indexName} on table {tableName} which is not included in the selection set. Skipping.
        /// </summary>
        public static string IndexColumnNotInSelectionSet([CanBeNull] object columnName, [CanBeNull] object indexName, [CanBeNull] object tableName)
            => string.Format(
                GetString("IndexColumnNotInSelectionSet", nameof(columnName), nameof(indexName), nameof(tableName)),
                columnName, indexName, tableName);

        /// <summary>
        ///     Found sequence name: {name}, data type: {dataType}, cyclic: {isCyclic}, increment: {increment}, start: {start}, minimum: {min}, maximum: {max}.
        /// </summary>
        public static string FoundSequence([CanBeNull] object name, [CanBeNull] object dataType, [CanBeNull] object isCyclic, [CanBeNull] object increment, [CanBeNull] object start, [CanBeNull] object min, [CanBeNull] object max)
            => string.Format(
                GetString("FoundSequence", nameof(name), nameof(dataType), nameof(isCyclic), nameof(increment), nameof(start), nameof(min), nameof(max)),
                name, dataType, isCyclic, increment, start, min, max);

        /// <summary>
        ///     Found a column on foreign key {tableName}.{fkName} with an empty or null name. Not including column in foreign key
        /// </summary>
        public static string ColumnNameEmptyOnForeignKey([CanBeNull] object tableName, [CanBeNull] object fkName)
            => string.Format(
                GetString("ColumnNameEmptyOnForeignKey", nameof(tableName), nameof(fkName)),
                tableName, fkName);

        /// <summary>
        ///     Found a column on table {tableName} with an empty or null name. Skipping column.
        /// </summary>
        public static string ColumnNameEmptyOnTable([CanBeNull] object tableName)
            => string.Format(
                GetString("ColumnNameEmptyOnTable", nameof(tableName)),
                tableName);

        /// <summary>
        ///     For index {indexName}. Unable to find parent table {tableName}. Skipping index.
        /// </summary>
        public static string UnableToFindTableForIndex([CanBeNull] object indexName, [CanBeNull] object tableName)
            => string.Format(
                GetString("UnableToFindTableForIndex", nameof(indexName), nameof(tableName)),
                indexName, tableName);

        /// <summary>
        ///     Found an index on table {tableName} with an empty or null name. Skipping index.
        /// </summary>
        public static string IndexNameEmpty([CanBeNull] object tableName)
            => string.Format(
                GetString("IndexNameEmpty", nameof(tableName)),
                tableName);

        /// <summary>
        ///     Found a foreign key on table {tableName} with an empty or null name. Skipping foreign key.
        /// </summary>
        public static string ForeignKeyNameEmpty([CanBeNull] object tableName)
            => string.Format(
                GetString("ForeignKeyNameEmpty", nameof(tableName)),
                tableName);

        /// <summary>
        ///     Foreign key column {columnName} belongs to foreign key {fkName} on table {tableName} which is not included in the selection set. Skipping.
        /// </summary>
        public static string ForeignKeyColumnNotInSelectionSet([CanBeNull] object columnName, [CanBeNull] object fkName, [CanBeNull] object tableName)
            => string.Format(
                GetString("ForeignKeyColumnNotInSelectionSet", nameof(columnName), nameof(fkName), nameof(tableName)),
                columnName, fkName, tableName);

        /// <summary>
        ///     For foreign key {fkName} on table {tableName}, unable to model the end of the foreign key on principal table {principaltableName}. This is usually because the principal table was not included in the selection set.
        /// </summary>
        public static string PrincipalTableNotInSelectionSet([CanBeNull] object fkName, [CanBeNull] object tableName, [CanBeNull] object principaltableName)
            => string.Format(
                GetString("PrincipalTableNotInSelectionSet", nameof(fkName), nameof(tableName), nameof(principaltableName)),
                fkName, tableName, principaltableName);

        /// <summary>
        ///     Unable to generate entity type for table '{tableName}'.
        /// </summary>
        public static string UnableToGenerateEntityType([CanBeNull] object tableName)
            => string.Format(
                GetString("UnableToGenerateEntityType", nameof(tableName)),
                tableName);

        /// <summary>
        ///     Unable to scaffold the index '{indexName}'. The following columns could not be scaffolded: {columnNames}.
        /// </summary>
        public static string UnableToScaffoldIndexMissingProperty([CanBeNull] object indexName, [CanBeNull] object columnNames)
            => string.Format(
                GetString("UnableToScaffoldIndexMissingProperty", nameof(indexName), nameof(columnNames)),
                indexName, columnNames);

        /// <summary>
        ///     Sequence name cannot be null or empty. Entity Framework cannot model a sequence that does not have a name.
        /// </summary>
        public static string SequencesRequireName
            => GetString("SequencesRequireName");

        /// <summary>
        ///     For sequence '{sequenceName}'. Unable to scaffold because it uses an unsupported type: '{typeName}'.
        /// </summary>
        public static string BadSequenceType([CanBeNull] object sequenceName, [CanBeNull] object typeName)
            => string.Format(
                GetString("BadSequenceType", nameof(sequenceName), nameof(typeName)),
                sequenceName, typeName);

        /// <summary>
        ///     Unable to find a schema in the database matching the selected schema {schema}.
        /// </summary>
        public static string MissingSchema([CanBeNull] object schema)
            => string.Format(
                GetString("MissingSchema", nameof(schema)),
                schema);

        /// <summary>
        ///     Unable to find a table in the database matching the selected table {table}.
        /// </summary>
        public static string MissingTable([CanBeNull] object table)
            => string.Format(
                GetString("MissingTable", nameof(table)),
                table);

        /// <summary>
        ///     The principal end of the foreign key '{foreignKeyName}' is supported by the unique index '{indexName}' and contains the following nullable columns '{columnNames}'. Entity Framework requires the properties representing those columns to be non-nullable.
        /// </summary>
        public static string ForeignKeyPrincipalEndContainsNullableColumns([CanBeNull] object foreignKeyName, [CanBeNull] object indexName, [CanBeNull] object columnNames)
            => string.Format(
                GetString("ForeignKeyPrincipalEndContainsNullableColumns", nameof(foreignKeyName), nameof(indexName), nameof(columnNames)),
                foreignKeyName, indexName, columnNames);

        private static string GetString(string name, params string[] formatterNames)
        {
            var value = _resourceManager.GetString(name);
            for (var i = 0; i < formatterNames.Length; i++)
            {
                value = value.Replace("{" + formatterNames[i] + "}", "{" + i + "}");
            }

            return value;
        }
    }
}
